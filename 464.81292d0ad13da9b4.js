"use strict";(self.webpackChunkngx_cocktail_view_animations=self.webpackChunkngx_cocktail_view_animations||[]).push([[464],{464:(r,o,i)=>{i.r(o),i.d(o,{default:()=>l});var s=i(6814),e=i(4946);let l=(()=>{class t{}return t.\u0275fac=function(a){return new(a||t)},t.\u0275cmp=e.Xpm({type:t,selectors:[["ngx-cocktail-view-animations-about"]],standalone:!0,features:[e.jDz],decls:92,vars:0,consts:[[1,"container","m-auto","mb-32"],[1,"text-4xl","font-bold","md:leading-tight","dark:text-white"],[1,"mt-8","text-2xl","font-bold","md:leading-tight","dark:text-white","text-slate-600"],[1,"mt-2"],[1,"inline-flex","flex-wrap","gap-2"],[1,"bg-blue-100","text-blue-800","text-xs","font-medium","px-2.5","py-0.5","rounded","dark:bg-blue-900","dark:text-blue-300"],[1,"mt-8","text-2xl","md:leading-tight","dark:text-white","text-slate-600"],[1,"max-w-md","space-y-1","text-gray-500","list-disc","list-inside"]],template:function(a,u){1&a&&(e.TgZ(0,"div",0)(1,"h2",1),e._uU(2,"About"),e.qZA(),e.TgZ(3,"h3",2),e._uU(4," General "),e.qZA(),e.TgZ(5,"p"),e._uU(6,' This application is for testing view transition api on a "real life" application. '),e.TgZ(7,"b"),e._uU(8,"This will not be maintained!"),e.qZA()(),e.TgZ(9,"p"),e._uU(10," I created this application to see/fix the bottlenecks, but also to see how easy I could make it by hiding away functionality using directives and a custom router outlet. There are not a lot of examples available for Angular, so I saw this as a challenge! while doing so I also looked into TailwindCSS, the new setup of Angular (standalone, inject DI) "),e.qZA(),e.TgZ(11,"p",3),e._uU(12," Topics: "),e.TgZ(13,"span",4)(14,"span",5),e._uU(15," View transition api "),e.qZA(),e.TgZ(16,"span",5),e._uU(17," TailwindCSS "),e.qZA(),e.TgZ(18,"span",5),e._uU(19," standalone components/directives (angular) "),e.qZA(),e.TgZ(20,"span",5),e._uU(21," inject using properties instead of ctor (angular) "),e.qZA()()(),e.TgZ(22,"h3",2),e._uU(23," Challenges view transition "),e.qZA(),e.TgZ(24,"h4",6),e._uU(25," Challenge 1: hook into view transition api "),e.qZA(),e.TgZ(26,"p"),e._uU(27," I didn't find any hooks on the router to execute logic. I would have thought that the router module provided some strategy that I could implement, but this was not the case. I was thinking to create my own router logic, while I stumbled upon the idea that you can "),e.TgZ(28,"b"),e._uU(29,"create your own router outlet"),e.qZA(),e._uU(30," directive. By doing so, I could add the behavior that I wanted. The only downside is that this only goes 1 level deep. A strategy on router configuration level would be better as there would be 1 orchestrator. However currently each router-outlet handles their own component and passes information down. "),e.qZA(),e.TgZ(31,"p")(32,"b"),e._uU(33,"Note: "),e.qZA(),e._uU(34,"Nested router-outlets are in this demo not supported, as the animation is marked as complete as 1 router outlet is finished. "),e.qZA(),e.TgZ(35,"h4",6),e._uU(36," Challenge 2: Duplicate view transition name inside lists/overviews "),e.qZA(),e.TgZ(37,"p"),e._uU(38," If you have a list of items and you want to animate is separately. for example: the list of cocktails has each their own name and picture. Those are 2 different names as you want to animate it in a different way. However if you add a view transition name on each item with the same name then nothing will work as this needs to be unique. Adding a unique view transition name (for eaxmple by using the id) is also possible but then your detail page needs to be adapted to this as well. Online solution for different technologies did it mostly manually by writing custom javascript on click. while this gives flexibility, it doesn't scale well and is not usable if you use routerLink inside Angular. I could have created my own routerLink directive that would do the same thing, but I went another way by using another directive (vwtRepeatedTransitionContainer). "),e.TgZ(39,"b"),e._uU(40,"With this container the view transition is only applied on the elements where the navigation is being triggered."),e.qZA(),e._uU(41,' In the custom router outlet we will look for this container and look at the inside to check all routerLinks to see which routes are possible. only the routerlink where you navigate to will be "activated" with the view transition name. '),e.qZA(),e.TgZ(42,"h4",6),e._uU(43," Challenge 3: direction of navigation "),e.qZA(),e.TgZ(44,"p"),e._uU(45,' While it is possible to change the animation depending the direction of the navigation (for example: go back), because we configure it only using css. The problem lies that the routerLinkDirective always sees this as a new route navigation event. for example going from a detail to an overview page using "routerlink=".."" will be marked as a new navigation going forward, instead of backwards. I didn\'t focus on this here, as it would lead me to far into what is possible. The next challenge had also to do with navigation. '),e.qZA(),e.TgZ(46,"h4",6),e._uU(47," Challenge 4: navigation & restore scroll position "),e.qZA(),e.TgZ(48,"p"),e._uU(49," if you were scrolling on a large overview page and clicking on a detail, you navigate to that detail with the right animation. However if you go back, the scroll position was not restored, thus the animation was also no so nice looking. I investigated and saw that there is a scroll restoration option to work on going back a page, but this only works when using the browsers back buttons. This is the same (strange) behavior like in the previous challenge. "),e.qZA(),e.TgZ(50,"h4",6),e._uU(51," Challenge 5: async data "),e.qZA(),e.TgZ(52,"p"),e._uU(53,' A lot of times i\'ve used *ngIf="someObs$ |async as someObs" syntax to subscribe to data to visualize. The problem only lies in the fact that my router outlet needed to know when the transition could be done. '),e.qZA(),e.TgZ(54,"p"),e._uU(55," I have found a "),e.TgZ(56,"b"),e._uU(57,'"ChangeDetectionCoordinator" class'),e.qZA(),e._uU(58,' that uses the macrotask "setTimeOut" and a "tick" for the whole application to "wait" if everything is being rendered. This means that it just renders the new component and after that it will start the animation. calling an endpoint seems to happen to late. Even worse, because I used the ngIf as syntax, there was no DOM element, so also no element with such a view transition name, meaning there was no animation for this element. '),e.qZA(),e.TgZ(59,"p"),e._uU(60," A possible solution I've used was to use the "),e.TgZ(61,"b"),e._uU(62,'"resolve" on the route'),e.qZA(),e._uU(63," to wait until this data is available. However I'm currently not pleased with this, as this blocks the whole rendering, without showing something to the user. "),e.qZA(),e.TgZ(64,"p"),e._uU(65," Another option would be to use a new directive "),e.TgZ(66,"b"),e._uU(67,"*ngLet with as syntax"),e.qZA(),e._uU(68,", so that there would be a DOM element with that name. NgLet doesn't exists, but is easily created. Downside of this means a lot more null checks. An enhancement to previous option is to look at skeleton loading with it. "),e.qZA(),e.TgZ(69,"h3",2),e._uU(70," Open issues "),e.qZA(),e.TgZ(71,"p"),e._uU(72,"There are a lot issues/improvements that could be made:"),e.qZA(),e.TgZ(73,"ul",7)(74,"li"),e._uU(75,"avoid flickering after animation"),e.qZA(),e.TgZ(76,"li"),e._uU(77,"navigating back seems to have broken the overview page"),e.qZA(),e.TgZ(78,"li"),e._uU(79,"animation detail page: content should appear after animation"),e.qZA(),e.TgZ(80,"li"),e._uU(81,"activate NgOptimizedImage for images"),e.qZA(),e.TgZ(82,"li"),e._uU(83,"look & feel"),e.qZA(),e.TgZ(84,"li"),e._uU(85," add more nicer animations (currently default behavior with writing css) "),e.qZA(),e.TgZ(86,"li"),e._uU(87,"Scroll position restoration"),e.qZA(),e.TgZ(88,"li"),e._uU(89,"continue application with overview by alcohol, glass, ..."),e.qZA(),e.TgZ(90,"li"),e._uU(91,"page transitions"),e.qZA()()())},dependencies:[s.ez],encapsulation:2}),t})()}}]);